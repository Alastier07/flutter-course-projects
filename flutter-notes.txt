-- Create project --
	1. Go to your folder path you want to create your project.
		- cd "folder path"
			ex. cd C:\Users\admin\Desktop\development\projects
	2. Create flutter by this command;
		- flutter create "name of folder project"
			ex. flutter create myfirst_project
	3. And now you can open your project folder in VSCode
		- notes: Install dart & flutter extension in VSCode.

-- Run flutter project --
	1. Go to vscode terminal and run this command (note: make sure you are in project path location).
		- flutter run
	2. Press r to hot reload and shift + r (R) to hot restart.
	3. Press q to exit running app.

-- Run flutter packages get --
	1. To ensure the flutter to fix up the yaml file. Go to terminal and run this command;
		flutter packages get

-- Dart Fundamentals --
	1. Types describe which type of data you're using in a variable, function etc.
	2. Variables are basically data containers.
	3. Functions are basically "code snippets" which you write once to then use them as often and whenever you want.
	4. Classes act as blueprints that describe how an object should look like. You create ("instantiate") a class by executing it like a function.
	5. You can have class-level variables (which you then can access from anywhere inside the class) - such variables are then called properties. Side note: Functions inside of a class are called "methods".
	6. String = It's a "string of characters", hence the name.

-- Flutter App Basics --
	1. runApp() -> This function takes the widget object you pass to it and ensures that the widget tree of that widget gets created.
	2. build() returns a so-called "widget tree" which tells Flutter what to draw onto the screen.
	3. Flutter is all about buildings apps and for that, you need user interfaces. You build these user interfaces with Widgets => The core UI building blocks.

-- Widget Basics --
	1. Widgets are your core UI building block.
	2. Widgets are just Dart objects. They need to extend StatelessWidget or StatefulWidget though (and implement a build() method).
	3. Widget Tree -> A typical Flutter app UI consists of multiple layers of Widgets which together form the look you want.
	4. Widgets are the UI elements you mix together to build a user interface.
	5. Combine Widgets -> Most Widgets have some (named) arguments that require another Widget - e.g. the "children" argument on the Column() constructor. Or "child" on Container().
	6. Widgets are normal Dart classes / objects. But they're only usable as Widgets if you extend StatelessWidget or StatefulWidget and add a build() method.

-- Stateful and Stateless Widget --
	1. The core difference between StatelessWidget and StatefulWidget is whilst you can add (and also change) properties in a StatelessWidget, there's no way of telling Flutter that it should re-run build() upon such changes.
	2. All widgets (i.e. both Stateless and Stateful) can receive data via their constructors. But only StatefulWidgets can have class properties where they can update values + re-run build().
	3. setState() is a "trigger" that informs Flutter that it needs to re-run build() of the Widget.

-- Advance Flutter & Dart Basics --
	1. The leading "_" marks a class, property or method as private, which means that you can only use it in the same library. Typically, a file is treated as a separate library.
	2. enum -> is a value where you can choose from multiple possible choices. You choose by selecting a huma-readable label, behind the scenes, the label are mapped to integers (0, 1, ...)
	3. You can have more than one constructor in your Dart classes. Extra constructors typically yield you differently configured objects of the same type.
	4. Maps are basically like Lists without number indexes but custom indexes (keys).
	5. map() returns a new iterable (which is transformed to a list via toList()) where each value of the original list (names) is transformed as "described" by the function you pass to map. In this case, each name is wrapped into a Text() widget and then added to the new list which is stored in result.
	6. final -> At runtime, an initial, dynamic value can be assigned, thereafter, the property / variable can't be changed again.

-- Null Safety --
	1. inputing ? to type variable like this "String? username;" is to tell that username can be null value.

-- Old button to new button --
	RaisedButton => ElevatedButton
	FlatButton => TextButton
	OutlineButton => OutlinedButton

-- Important Widgets --
	App/Page Setup: MaterialApp/CupertinoApp, Scaffold/CupertinoPageScaffold
	Layout: Container, Row, Column
	Row/Column Children: Flexible, Expanded
	Content Containers: Stack, Card
	Repeat Elements: ListView, GridView, ListTile
	Content Types: Text, Image, Icon
	User Input: TextField, RaisedButton/FlatButton, GestureDetector, InkWell

-- Row and Column --
	1. Rows and Columns are used to organize multiple sibling widgets.
	2. Columns by default span across the entire vertical space they can get.
	3. You can absolutely have a Row in a Column, a Column in a Row or Rows in Rows / Columns in Columns.

-- Styling --
	1. You configure widgets via their constructor arguments - that includes styling config.
	2. BoxDecoration() creates a decoration object which you can configure in many different ways (e.g. border, radius, color) via its constructor arguments.
	3. Use the many resources you got for which constructor wants and which kind of value need. IDE support + official docs.
	
	